% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unified-client.R
\name{UnifiedClient}
\alias{UnifiedClient}
\title{UnifiedClient}
\description{
An R6 class that provides a unified interface to AstraeaDB by automatically
selecting the best available transport. It always creates a JSON/TCP client
(\code{\link{AstraeaClient}}) and optionally creates an Arrow Flight client
(\code{\link{ArrowClient}}) when the \pkg{arrow} package is installed.
}
\details{
The UnifiedClient delegates all CRUD operations (node, edge, traversal,
vector search, etc.) to the JSON/TCP client. For GQL query execution,
it prefers the Arrow Flight transport when available, as Arrow provides
more efficient columnar data transfer for analytical workloads. If Arrow
is not available or its connection fails, queries transparently fall back
to the JSON/TCP transport.

Typical usage:
\enumerate{
\item Create a \code{UnifiedClient} instance.
\item Call \code{$connect()} to establish connections.
\item Use CRUD methods (\code{$create_node()}, \code{$get_node()}, etc.)
and query methods (\code{$query()}, \code{$query_df()}).
\item Call \code{$disconnect()} when finished.
}
}
\examples{
\dontrun{
# Basic usage
client <- UnifiedClient$new()
client$connect()

# CRUD operations use JSON/TCP
node_id <- client$create_node(list("Person"), list(name = "Alice", age = 30))
node <- client$get_node(node_id)

# Queries use Arrow Flight if available, otherwise JSON/TCP
df <- client$query_df("MATCH (n:Person) RETURN n.name, n.age")

# Check transport status
client$is_arrow_enabled()

client$disconnect()

# With authentication
client <- UnifiedClient$new(auth_token = "my-secret-token")
client$connect()

# Custom Flight URI
client <- UnifiedClient$new(
  host = "db.example.com",
  port = 7687L,
  flight_uri = "grpc://db.example.com:7689"
)
client$connect()
}


## ------------------------------------------------
## Method `UnifiedClient$query`
## ------------------------------------------------

\dontrun{
client <- UnifiedClient$new()
client$connect()
result <- client$query("MATCH (n:Person) RETURN n.name")
client$disconnect()
}

## ------------------------------------------------
## Method `UnifiedClient$query_df`
## ------------------------------------------------

\dontrun{
client <- UnifiedClient$new()
client$connect()
df <- client$query_df("MATCH (n:Person) RETURN n.name, n.age")
client$disconnect()
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{json_client}}{An \code{\link{AstraeaClient}} instance for JSON/TCP
communication. Always available.}

\item{\code{arrow_client}}{An \code{\link{ArrowClient}} instance for Arrow
Flight communication, or \code{NULL} if the \pkg{arrow} package is not
installed or initialization failed.}

\item{\code{use_arrow}}{Logical. Whether Arrow Flight transport is active and
should be used for queries.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-UnifiedClient-new}{\code{UnifiedClient$new()}}
\item \href{#method-UnifiedClient-connect}{\code{UnifiedClient$connect()}}
\item \href{#method-UnifiedClient-disconnect}{\code{UnifiedClient$disconnect()}}
\item \href{#method-UnifiedClient-create_node}{\code{UnifiedClient$create_node()}}
\item \href{#method-UnifiedClient-get_node}{\code{UnifiedClient$get_node()}}
\item \href{#method-UnifiedClient-update_node}{\code{UnifiedClient$update_node()}}
\item \href{#method-UnifiedClient-delete_node}{\code{UnifiedClient$delete_node()}}
\item \href{#method-UnifiedClient-create_edge}{\code{UnifiedClient$create_edge()}}
\item \href{#method-UnifiedClient-get_edge}{\code{UnifiedClient$get_edge()}}
\item \href{#method-UnifiedClient-update_edge}{\code{UnifiedClient$update_edge()}}
\item \href{#method-UnifiedClient-delete_edge}{\code{UnifiedClient$delete_edge()}}
\item \href{#method-UnifiedClient-neighbors}{\code{UnifiedClient$neighbors()}}
\item \href{#method-UnifiedClient-bfs}{\code{UnifiedClient$bfs()}}
\item \href{#method-UnifiedClient-shortest_path}{\code{UnifiedClient$shortest_path()}}
\item \href{#method-UnifiedClient-neighbors_at}{\code{UnifiedClient$neighbors_at()}}
\item \href{#method-UnifiedClient-bfs_at}{\code{UnifiedClient$bfs_at()}}
\item \href{#method-UnifiedClient-shortest_path_at}{\code{UnifiedClient$shortest_path_at()}}
\item \href{#method-UnifiedClient-vector_search}{\code{UnifiedClient$vector_search()}}
\item \href{#method-UnifiedClient-hybrid_search}{\code{UnifiedClient$hybrid_search()}}
\item \href{#method-UnifiedClient-semantic_neighbors}{\code{UnifiedClient$semantic_neighbors()}}
\item \href{#method-UnifiedClient-semantic_walk}{\code{UnifiedClient$semantic_walk()}}
\item \href{#method-UnifiedClient-extract_subgraph}{\code{UnifiedClient$extract_subgraph()}}
\item \href{#method-UnifiedClient-graph_rag}{\code{UnifiedClient$graph_rag()}}
\item \href{#method-UnifiedClient-anomaly_check}{\code{UnifiedClient$anomaly_check()}}
\item \href{#method-UnifiedClient-anomaly_stats}{\code{UnifiedClient$anomaly_stats()}}
\item \href{#method-UnifiedClient-anomaly_alerts}{\code{UnifiedClient$anomaly_alerts()}}
\item \href{#method-UnifiedClient-create_nodes}{\code{UnifiedClient$create_nodes()}}
\item \href{#method-UnifiedClient-create_edges}{\code{UnifiedClient$create_edges()}}
\item \href{#method-UnifiedClient-delete_nodes}{\code{UnifiedClient$delete_nodes()}}
\item \href{#method-UnifiedClient-delete_edges}{\code{UnifiedClient$delete_edges()}}
\item \href{#method-UnifiedClient-import_nodes_df}{\code{UnifiedClient$import_nodes_df()}}
\item \href{#method-UnifiedClient-import_edges_df}{\code{UnifiedClient$import_edges_df()}}
\item \href{#method-UnifiedClient-export_nodes_df}{\code{UnifiedClient$export_nodes_df()}}
\item \href{#method-UnifiedClient-export_bfs_df}{\code{UnifiedClient$export_bfs_df()}}
\item \href{#method-UnifiedClient-results_to_dataframe}{\code{UnifiedClient$results_to_dataframe()}}
\item \href{#method-UnifiedClient-nodes_to_dataframe}{\code{UnifiedClient$nodes_to_dataframe()}}
\item \href{#method-UnifiedClient-ping}{\code{UnifiedClient$ping()}}
\item \href{#method-UnifiedClient-query}{\code{UnifiedClient$query()}}
\item \href{#method-UnifiedClient-query_df}{\code{UnifiedClient$query_df()}}
\item \href{#method-UnifiedClient-is_arrow_enabled}{\code{UnifiedClient$is_arrow_enabled()}}
\item \href{#method-UnifiedClient-print}{\code{UnifiedClient$print()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-new"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-new}{}}}
\subsection{Method \code{new()}}{
Create a new UnifiedClient.

Always creates a JSON/TCP client. If the \pkg{arrow} package is
available, also creates an Arrow Flight client. Arrow initialization
failure is non-fatal and results in a message.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$new(
  host = "127.0.0.1",
  port = 7687L,
  flight_uri = NULL,
  auth_token = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{host}}{Character. Server hostname for JSON/TCP transport.
Defaults to \code{"127.0.0.1"}.}

\item{\code{port}}{Integer. Server port for JSON/TCP transport.
Defaults to \code{7687L}.}

\item{\code{flight_uri}}{Character or \code{NULL}. Arrow Flight gRPC URI.
If \code{NULL}, constructed automatically as
\code{sprintf("grpc://\%s:7689", host)}.}

\item{\code{auth_token}}{Character or \code{NULL}. Authentication token for
the JSON/TCP client.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{UnifiedClient} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-connect"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-connect}{}}}
\subsection{Method \code{connect()}}{
Connect to AstraeaDB server(s).

Connects the JSON/TCP client. If Arrow Flight is enabled, also attempts
to connect the Arrow client. Arrow connection failure is non-fatal and
results in a fallback to JSON/TCP with a message.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$connect()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns \code{self} for method chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-disconnect"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-disconnect}{}}}
\subsection{Method \code{disconnect()}}{
Disconnect all client connections.

Closes the JSON/TCP connection and, if active, the Arrow Flight
connection.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$disconnect()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns \code{self} for method chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-create_node"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-create_node}{}}}
\subsection{Method \code{create_node()}}{
Create a node. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$create_node(labels, properties, embedding = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{labels}}{List of character labels for the node.}

\item{\code{properties}}{Named list of node properties.}

\item{\code{embedding}}{Optional numeric vector for vector similarity search.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer. The ID of the newly created node.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-get_node"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-get_node}{}}}
\subsection{Method \code{get_node()}}{
Get a node by ID. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$get_node(node_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer. The node ID.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list containing node data (labels, properties, etc.).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-update_node"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-update_node}{}}}
\subsection{Method \code{update_node()}}{
Update a node's properties. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$update_node(node_id, properties)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer. The node ID.}

\item{\code{properties}}{Named list of properties to merge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-delete_node"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-delete_node}{}}}
\subsection{Method \code{delete_node()}}{
Delete a node and its connected edges. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$delete_node(node_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer. The node ID.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-create_edge"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-create_edge}{}}}
\subsection{Method \code{create_edge()}}{
Create an edge. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$create_edge(
  source,
  target,
  edge_type,
  properties = list(),
  weight = 1,
  valid_from = NULL,
  valid_to = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{source}}{Integer. Source node ID.}

\item{\code{target}}{Integer. Target node ID.}

\item{\code{edge_type}}{Character. The edge type label.}

\item{\code{properties}}{Named list of edge properties.}

\item{\code{weight}}{Numeric. Edge weight. Defaults to \code{1.0}.}

\item{\code{valid_from}}{Numeric or \code{NULL}. Temporal start (ms epoch).}

\item{\code{valid_to}}{Numeric or \code{NULL}. Temporal end (ms epoch).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer. The ID of the newly created edge.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-get_edge"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-get_edge}{}}}
\subsection{Method \code{get_edge()}}{
Get an edge by ID. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$get_edge(edge_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_id}}{Integer. The edge ID.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list containing edge data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-update_edge"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-update_edge}{}}}
\subsection{Method \code{update_edge()}}{
Update an edge's properties. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$update_edge(edge_id, properties)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_id}}{Integer. The edge ID.}

\item{\code{properties}}{Named list of properties to merge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-delete_edge"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-delete_edge}{}}}
\subsection{Method \code{delete_edge()}}{
Delete an edge. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$delete_edge(edge_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_id}}{Integer. The edge ID.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-neighbors"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-neighbors}{}}}
\subsection{Method \code{neighbors()}}{
Get neighbors of a node. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$neighbors(node_id, direction = "outgoing", edge_type = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer. The node ID.}

\item{\code{direction}}{Character. One of \code{"outgoing"}, \code{"incoming"},
or \code{"both"}. Defaults to \code{"outgoing"}.}

\item{\code{edge_type}}{Character or \code{NULL}. Filter by edge type.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of neighbor entries.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-bfs"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-bfs}{}}}
\subsection{Method \code{bfs()}}{
Breadth-first search from a start node. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$bfs(start, max_depth = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer. Starting node ID.}

\item{\code{max_depth}}{Integer. Maximum traversal depth. Defaults to \code{3L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of entries with \code{node_id} and \code{depth}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-shortest_path"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-shortest_path}{}}}
\subsection{Method \code{shortest_path()}}{
Find the shortest path between two nodes. Delegates to the JSON/TCP
client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$shortest_path(from_node, to_node, weighted = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_node}}{Integer. Source node ID.}

\item{\code{to_node}}{Integer. Target node ID.}

\item{\code{weighted}}{Logical. Use edge weights? Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with path information.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-neighbors_at"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-neighbors_at}{}}}
\subsection{Method \code{neighbors_at()}}{
Get neighbors at a specific point in time. Delegates to the JSON/TCP
client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$neighbors_at(
  node_id,
  direction = "outgoing",
  timestamp,
  edge_type = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer. The node ID.}

\item{\code{direction}}{Character. Direction filter. Defaults to
\code{"outgoing"}.}

\item{\code{timestamp}}{Numeric. Point-in-time timestamp (ms epoch).}

\item{\code{edge_type}}{Character or \code{NULL}. Filter by edge type.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of neighbor entries valid at the given timestamp.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-bfs_at"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-bfs_at}{}}}
\subsection{Method \code{bfs_at()}}{
BFS traversal at a specific point in time. Delegates to the JSON/TCP
client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$bfs_at(start, max_depth = 3L, timestamp)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer. Starting node ID.}

\item{\code{max_depth}}{Integer. Maximum depth. Defaults to \code{3L}.}

\item{\code{timestamp}}{Numeric. Point-in-time timestamp (ms epoch).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of entries with \code{node_id} and \code{depth}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-shortest_path_at"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-shortest_path_at}{}}}
\subsection{Method \code{shortest_path_at()}}{
Find shortest path at a specific point in time. Delegates to the
JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$shortest_path_at(from_node, to_node, timestamp, weighted = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_node}}{Integer. Source node ID.}

\item{\code{to_node}}{Integer. Target node ID.}

\item{\code{timestamp}}{Numeric. Point-in-time timestamp (ms epoch).}

\item{\code{weighted}}{Logical. Use edge weights? Defaults to \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with path information.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-vector_search"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-vector_search}{}}}
\subsection{Method \code{vector_search()}}{
k-nearest neighbor vector search. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$vector_search(query_vector, k = 10L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query_vector}}{Numeric vector. The query embedding.}

\item{\code{k}}{Integer. Number of results. Defaults to \code{10L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of search results with \code{node_id} and
\code{similarity}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-hybrid_search"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-hybrid_search}{}}}
\subsection{Method \code{hybrid_search()}}{
Hybrid graph-vector search. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$hybrid_search(
  anchor,
  query_vector,
  max_hops = 3L,
  k = 10L,
  alpha = 0.5
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{anchor}}{Integer. Anchor node ID for graph proximity.}

\item{\code{query_vector}}{Numeric vector. Query embedding for similarity.}

\item{\code{max_hops}}{Integer. Maximum graph hops. Defaults to \code{3L}.}

\item{\code{k}}{Integer. Number of results. Defaults to \code{10L}.}

\item{\code{alpha}}{Numeric. Balance between graph (0) and vector (1).
Defaults to \code{0.5}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of search results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-semantic_neighbors"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-semantic_neighbors}{}}}
\subsection{Method \code{semantic_neighbors()}}{
Get neighbors ranked by semantic similarity. Delegates to the JSON/TCP
client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$semantic_neighbors(
  node_id,
  concept,
  direction = "outgoing",
  k = 10L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer. The node ID.}

\item{\code{concept}}{Numeric vector. Concept embedding for ranking.}

\item{\code{direction}}{Character. Direction filter. Defaults to
\code{"outgoing"}.}

\item{\code{k}}{Integer. Number of results. Defaults to \code{10L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of neighbor entries with similarity scores.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-semantic_walk"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-semantic_walk}{}}}
\subsection{Method \code{semantic_walk()}}{
Greedy semantic walk following edges most similar to a concept.
Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$semantic_walk(start, concept, max_hops = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer. Starting node ID.}

\item{\code{concept}}{Numeric vector. Concept embedding for guidance.}

\item{\code{max_hops}}{Integer. Maximum walk length. Defaults to \code{3L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list representing the walk path.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-extract_subgraph"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-extract_subgraph}{}}}
\subsection{Method \code{extract_subgraph()}}{
Extract a subgraph centered on a node. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$extract_subgraph(
  center,
  hops = 2L,
  max_nodes = 50L,
  format = "structured"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{center}}{Integer. Center node ID.}

\item{\code{hops}}{Integer. Radius in hops. Defaults to \code{2L}.}

\item{\code{max_nodes}}{Integer. Maximum nodes to return. Defaults to
\code{50L}.}

\item{\code{format}}{Character. Output format: \code{"structured"},
\code{"prose"}, \code{"triples"}, or \code{"json"}.
Defaults to \code{"structured"}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with subgraph data and linearized text.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-graph_rag"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-graph_rag}{}}}
\subsection{Method \code{graph_rag()}}{
Execute a GraphRAG query. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$graph_rag(
  question,
  anchor = NULL,
  question_embedding = NULL,
  hops = 2L,
  max_nodes = 50L,
  format = "structured"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{question}}{Character. The question to answer.}

\item{\code{anchor}}{Integer or \code{NULL}. Anchor node ID.}

\item{\code{question_embedding}}{Numeric vector or \code{NULL}. Embedding of
the question.}

\item{\code{hops}}{Integer. Subgraph radius. Defaults to \code{2L}.}

\item{\code{max_nodes}}{Integer. Maximum subgraph nodes. Defaults to
\code{50L}.}

\item{\code{format}}{Character. Linearization format. Defaults to
\code{"structured"}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the LLM-generated answer and context.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-anomaly_check"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-anomaly_check}{}}}
\subsection{Method \code{anomaly_check()}}{
Check anomaly status of an entity. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$anomaly_check(entity_id, is_node = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{entity_id}}{Integer. The node or edge ID.}

\item{\code{is_node}}{Logical. Check a node (\code{TRUE}) or edge
(\code{FALSE}). Defaults to \code{TRUE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with anomaly score information.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-anomaly_stats"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-anomaly_stats}{}}}
\subsection{Method \code{anomaly_stats()}}{
Get detailed anomaly statistics. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$anomaly_stats(entity_id, is_node = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{entity_id}}{Integer. The node or edge ID.}

\item{\code{is_node}}{Logical. Query a node (\code{TRUE}) or edge
(\code{FALSE}). Defaults to \code{TRUE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with detailed anomaly statistics.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-anomaly_alerts"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-anomaly_alerts}{}}}
\subsection{Method \code{anomaly_alerts()}}{
Get all active anomaly alerts. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$anomaly_alerts()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of alert entries.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-create_nodes"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-create_nodes}{}}}
\subsection{Method \code{create_nodes()}}{
Create multiple nodes. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$create_nodes(nodes_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nodes_list}}{A list of lists, each with \code{labels},
\code{properties}, and optionally \code{embedding}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created node IDs.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-create_edges"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-create_edges}{}}}
\subsection{Method \code{create_edges()}}{
Create multiple edges. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$create_edges(edges_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edges_list}}{A list of lists, each with \code{source},
\code{target}, \code{edge_type}, and optionally \code{properties},
\code{weight}, \code{valid_from}, \code{valid_to}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created edge IDs.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-delete_nodes"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-delete_nodes}{}}}
\subsection{Method \code{delete_nodes()}}{
Delete multiple nodes. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$delete_nodes(node_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_ids}}{Integer vector of node IDs to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer. Number of successfully deleted nodes.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-delete_edges"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-delete_edges}{}}}
\subsection{Method \code{delete_edges()}}{
Delete multiple edges. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$delete_edges(edge_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_ids}}{Integer vector of edge IDs to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer. Number of successfully deleted edges.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-import_nodes_df"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-import_nodes_df}{}}}
\subsection{Method \code{import_nodes_df()}}{
Import nodes from a data.frame. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$import_nodes_df(
  df,
  label_col = "label",
  id_col = NULL,
  embedding_cols = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{A data.frame containing node data.}

\item{\code{label_col}}{Character. Column name for labels.
Defaults to \code{"label"}.}

\item{\code{id_col}}{Character or \code{NULL}. Column for external IDs.}

\item{\code{embedding_cols}}{Character vector or \code{NULL}. Columns for
embedding values.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created node IDs.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-import_edges_df"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-import_edges_df}{}}}
\subsection{Method \code{import_edges_df()}}{
Import edges from a data.frame. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$import_edges_df(
  df,
  source_col = "source",
  target_col = "target",
  type_col = "type",
  weight_col = NULL,
  valid_from_col = NULL,
  valid_to_col = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{A data.frame containing edge data.}

\item{\code{source_col}}{Character. Column for source node IDs.
Defaults to \code{"source"}.}

\item{\code{target_col}}{Character. Column for target node IDs.
Defaults to \code{"target"}.}

\item{\code{type_col}}{Character. Column for edge types.
Defaults to \code{"type"}.}

\item{\code{weight_col}}{Character or \code{NULL}. Column for weights.}

\item{\code{valid_from_col}}{Character or \code{NULL}. Column for temporal
start.}

\item{\code{valid_to_col}}{Character or \code{NULL}. Column for temporal end.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created edge IDs.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-export_nodes_df"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-export_nodes_df}{}}}
\subsection{Method \code{export_nodes_df()}}{
Export nodes to a data.frame. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$export_nodes_df(node_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_ids}}{Integer vector of node IDs.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data.frame with columns for node ID, labels, and properties.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-export_bfs_df"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-export_bfs_df}{}}}
\subsection{Method \code{export_bfs_df()}}{
Run BFS and return results as a data.frame. Delegates to the JSON/TCP
client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$export_bfs_df(start, max_depth = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer. Starting node ID.}

\item{\code{max_depth}}{Integer. Maximum depth. Defaults to \code{3L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data.frame with BFS results including node details.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-results_to_dataframe"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-results_to_dataframe}{}}}
\subsection{Method \code{results_to_dataframe()}}{
Convert search results to a data.frame. Delegates to the JSON/TCP
client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$results_to_dataframe(results)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{results}}{A list of result entries.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data.frame with one row per result.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-nodes_to_dataframe"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-nodes_to_dataframe}{}}}
\subsection{Method \code{nodes_to_dataframe()}}{
Fetch nodes by ID and return as a data.frame. Delegates to the
JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$nodes_to_dataframe(node_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_ids}}{Integer vector of node IDs.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data.frame with columns for ID, labels, and properties.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-ping"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-ping}{}}}
\subsection{Method \code{ping()}}{
Health check. Delegates to the JSON/TCP client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$ping()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with server status information.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-query"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-query}{}}}
\subsection{Method \code{query()}}{
Execute a GQL query.

Uses Arrow Flight transport if available for higher performance.
Falls back to JSON/TCP transport otherwise.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$query(gql)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gql}}{Character. A GQL query string.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Query results. An Arrow Table when using Arrow transport, or a
list when using JSON/TCP.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client <- UnifiedClient$new()
client$connect()
result <- client$query("MATCH (n:Person) RETURN n.name")
client$disconnect()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-query_df"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-query_df}{}}}
\subsection{Method \code{query_df()}}{
Execute a GQL query and return a data.frame.

Uses Arrow Flight transport if available. Falls back to JSON/TCP,
converting the result to a data.frame.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$query_df(gql)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gql}}{Character. A GQL query string.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A data.frame containing the query results.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client <- UnifiedClient$new()
client$connect()
df <- client$query_df("MATCH (n:Person) RETURN n.name, n.age")
client$disconnect()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-is_arrow_enabled"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-is_arrow_enabled}{}}}
\subsection{Method \code{is_arrow_enabled()}}{
Check whether Arrow Flight transport is currently active.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$is_arrow_enabled()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Logical. \code{TRUE} if Arrow Flight is enabled and connected,
\code{FALSE} otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-UnifiedClient-print"></a>}}
\if{latex}{\out{\hypertarget{method-UnifiedClient-print}{}}}
\subsection{Method \code{print()}}{
Print a summary of the UnifiedClient.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{UnifiedClient$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Ignored. Present for compatibility with the generic.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns \code{self}.
}
}
}
