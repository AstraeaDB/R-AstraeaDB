% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/client.R
\name{AstraeaClient}
\alias{AstraeaClient}
\title{AstraeaDB Client}
\description{
R6 client for the AstraeaDB graph database using the JSON-over-TCP protocol.

The client communicates with an AstraeaDB server by sending JSON-encoded
request lines over a TCP socket and reading JSON-encoded response lines back.
Each request contains a \code{"type"} field identifying the operation, and
each response contains a \code{"status"} field (\code{"ok"} or
\code{"error"}) along with a \code{"data"} payload on success.

The client supports a comprehensive set of operations including:
\itemize{
\item Node and edge CRUD (create, read, update, delete)
\item Graph traversals (BFS, shortest path)
\item Temporal queries (time-travel over edges with validity windows)
\item GQL query execution
\item Vector similarity search (k-NN)
\item Hybrid graph-vector search
\item Semantic neighbor ranking and semantic walks
\item GraphRAG (subgraph extraction for LLM integration)
\item Anomaly detection ("deja vu" algorithm)
\item Batch and data frame import/export operations
}
}
\section{Connection}{

Create a client with \code{AstraeaClient$new()}, then call
\code{$connect()} to open the TCP socket. Always call \code{$disconnect()}
when finished, or use \code{\link[base]{on.exit}} to ensure cleanup.
}

\section{Authentication}{

If the server requires authentication, pass an \code{auth_token} to the
constructor. The token is automatically attached to every request.
}

\examples{
\dontrun{
# Connect to a local AstraeaDB server
client <- AstraeaClient$new()
client$connect()

# Health check
client$ping()

# Create nodes
alice_id <- client$create_node(
  labels = c("Person"),
  properties = list(name = "Alice", age = 30)
)
bob_id <- client$create_node(
  labels = c("Person"),
  properties = list(name = "Bob", age = 25)
)

# Create an edge
edge_id <- client$create_edge(
  source = alice_id,
  target = bob_id,
  edge_type = "KNOWS",
  properties = list(since = 2020)
)

# Traverse the graph
client$neighbors(alice_id, direction = "outgoing")
client$bfs(alice_id, max_depth = 2L)

# Clean up
client$disconnect()
}

## ------------------------------------------------
## Method `AstraeaClient$new`
## ------------------------------------------------

\dontrun{
client <- AstraeaClient$new()
client <- AstraeaClient$new(host = "db.example.com", port = 7688L)
client <- AstraeaClient$new(auth_token = "my-secret-token")
}

## ------------------------------------------------
## Method `AstraeaClient$connect`
## ------------------------------------------------

\dontrun{
client <- AstraeaClient$new()
client$connect()
}

## ------------------------------------------------
## Method `AstraeaClient$disconnect`
## ------------------------------------------------

\dontrun{
client$disconnect()
}

## ------------------------------------------------
## Method `AstraeaClient$is_connected`
## ------------------------------------------------

\dontrun{
client$is_connected()
}

## ------------------------------------------------
## Method `AstraeaClient$ping`
## ------------------------------------------------

\dontrun{
info <- client$ping()
message(info$version)
}

## ------------------------------------------------
## Method `AstraeaClient$create_node`
## ------------------------------------------------

\dontrun{
nid <- client$create_node(
  labels = c("Person"),
  properties = list(name = "Alice", age = 30),
  embedding = c(0.1, 0.9, 0.3)
)
}

## ------------------------------------------------
## Method `AstraeaClient$get_node`
## ------------------------------------------------

\dontrun{
node <- client$get_node(1L)
node$labels
node$properties$name
}

## ------------------------------------------------
## Method `AstraeaClient$update_node`
## ------------------------------------------------

\dontrun{
client$update_node(1L, list(city = "San Francisco"))
}

## ------------------------------------------------
## Method `AstraeaClient$delete_node`
## ------------------------------------------------

\dontrun{
client$delete_node(1L)
}

## ------------------------------------------------
## Method `AstraeaClient$create_edge`
## ------------------------------------------------

\dontrun{
eid <- client$create_edge(
  source    = 1L,
  target    = 2L,
  edge_type = "KNOWS",
  weight    = 0.9
)
}

## ------------------------------------------------
## Method `AstraeaClient$get_edge`
## ------------------------------------------------

\dontrun{
edge <- client$get_edge(1L)
edge$edge_type
}

## ------------------------------------------------
## Method `AstraeaClient$update_edge`
## ------------------------------------------------

\dontrun{
client$update_edge(1L, list(strength = "strong"))
}

## ------------------------------------------------
## Method `AstraeaClient$delete_edge`
## ------------------------------------------------

\dontrun{
client$delete_edge(1L)
}

## ------------------------------------------------
## Method `AstraeaClient$neighbors`
## ------------------------------------------------

\dontrun{
nbrs <- client$neighbors(1L, direction = "outgoing")
nbrs_knows <- client$neighbors(1L, edge_type = "KNOWS")
}

## ------------------------------------------------
## Method `AstraeaClient$bfs`
## ------------------------------------------------

\dontrun{
bfs_result <- client$bfs(1L, max_depth = 2L)
}

## ------------------------------------------------
## Method `AstraeaClient$shortest_path`
## ------------------------------------------------

\dontrun{
sp <- client$shortest_path(1L, 5L, weighted = TRUE)
sp$path
sp$cost
}

## ------------------------------------------------
## Method `AstraeaClient$neighbors_at`
## ------------------------------------------------

\dontrun{
# Neighbors as of January 1 2023 (ms since epoch)
nbrs <- client$neighbors_at(1L, "outgoing", 1672531200000)
}

## ------------------------------------------------
## Method `AstraeaClient$bfs_at`
## ------------------------------------------------

\dontrun{
result <- client$bfs_at(1L, max_depth = 2L, timestamp = 1672531200000)
}

## ------------------------------------------------
## Method `AstraeaClient$shortest_path_at`
## ------------------------------------------------

\dontrun{
sp <- client$shortest_path_at(1L, 5L, timestamp = 1672531200000)
}

## ------------------------------------------------
## Method `AstraeaClient$query`
## ------------------------------------------------

\dontrun{
result <- client$query("MATCH (p:Person) RETURN p.name, p.city")
}

## ------------------------------------------------
## Method `AstraeaClient$vector_search`
## ------------------------------------------------

\dontrun{
results <- client$vector_search(c(0.9, 0.1, 0.3), k = 5L)
}

## ------------------------------------------------
## Method `AstraeaClient$hybrid_search`
## ------------------------------------------------

\dontrun{
results <- client$hybrid_search(
  anchor = 1L,
  query_vector = c(0.9, 0.1, 0.3),
  k = 5L,
  alpha = 0.7
)
}

## ------------------------------------------------
## Method `AstraeaClient$semantic_neighbors`
## ------------------------------------------------

\dontrun{
nbrs <- client$semantic_neighbors(1L, c(0.0, 0.0, 1.0), k = 5L)
}

## ------------------------------------------------
## Method `AstraeaClient$semantic_walk`
## ------------------------------------------------

\dontrun{
path <- client$semantic_walk(1L, c(0.1, 0.8, 0.5), max_hops = 4L)
}

## ------------------------------------------------
## Method `AstraeaClient$extract_subgraph`
## ------------------------------------------------

\dontrun{
sg <- client$extract_subgraph(1L, hops = 2L, max_nodes = 20L)
sg$text
}

## ------------------------------------------------
## Method `AstraeaClient$graph_rag`
## ------------------------------------------------

\dontrun{
answer <- client$graph_rag(
  question = "What does Alice work on?",
  anchor = 1L
)
}

## ------------------------------------------------
## Method `AstraeaClient$anomaly_check`
## ------------------------------------------------

\dontrun{
result <- client$anomaly_check(1L)
result <- client$anomaly_check(5L, is_node = FALSE)
}

## ------------------------------------------------
## Method `AstraeaClient$anomaly_stats`
## ------------------------------------------------

\dontrun{
stats <- client$anomaly_stats(1L)
stats <- client$anomaly_stats(5L, is_node = FALSE)
}

## ------------------------------------------------
## Method `AstraeaClient$anomaly_alerts`
## ------------------------------------------------

\dontrun{
alerts <- client$anomaly_alerts()
for (a in alerts) {
  cat(sprintf("Entity \%d: score \%.2f\n", a$id, a$score))
}
}

## ------------------------------------------------
## Method `AstraeaClient$create_nodes`
## ------------------------------------------------

\dontrun{
ids <- client$create_nodes(list(
  list(labels = "Person", properties = list(name = "Alice")),
  list(labels = "Person", properties = list(name = "Bob"))
))
}

## ------------------------------------------------
## Method `AstraeaClient$create_edges`
## ------------------------------------------------

\dontrun{
eids <- client$create_edges(list(
  list(source = 1L, target = 2L, edge_type = "KNOWS"),
  list(source = 2L, target = 3L, edge_type = "FOLLOWS", weight = 0.5)
))
}

## ------------------------------------------------
## Method `AstraeaClient$delete_nodes`
## ------------------------------------------------

\dontrun{
deleted <- client$delete_nodes(c(1L, 2L, 3L))
}

## ------------------------------------------------
## Method `AstraeaClient$delete_edges`
## ------------------------------------------------

\dontrun{
deleted <- client$delete_edges(c(1L, 2L))
}

## ------------------------------------------------
## Method `AstraeaClient$import_nodes_df`
## ------------------------------------------------

\dontrun{
df <- data.frame(
  label = c("Person", "Person"),
  name  = c("Alice", "Bob"),
  age   = c(30, 25),
  stringsAsFactors = FALSE
)
ids <- client$import_nodes_df(df)
}

## ------------------------------------------------
## Method `AstraeaClient$import_edges_df`
## ------------------------------------------------

\dontrun{
edf <- data.frame(
  source = c(1L, 2L),
  target = c(2L, 3L),
  type   = c("KNOWS", "FOLLOWS"),
  stringsAsFactors = FALSE
)
eids <- client$import_edges_df(edf)
}

## ------------------------------------------------
## Method `AstraeaClient$export_nodes_df`
## ------------------------------------------------

\dontrun{
df <- client$export_nodes_df(c(1L, 2L, 3L))
}

## ------------------------------------------------
## Method `AstraeaClient$export_bfs_df`
## ------------------------------------------------

\dontrun{
bfs_df <- client$export_bfs_df(1L, max_depth = 2L)
}

## ------------------------------------------------
## Method `AstraeaClient$results_to_dataframe`
## ------------------------------------------------

\dontrun{
results <- client$vector_search(c(0.9, 0.1, 0.3), k = 5L)
df <- client$results_to_dataframe(results)
}

## ------------------------------------------------
## Method `AstraeaClient$nodes_to_dataframe`
## ------------------------------------------------

\dontrun{
df <- client$nodes_to_dataframe(c(1L, 2L, 3L))
df$labels[[1]]
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{host}}{Character scalar. Server hostname. Default \code{"127.0.0.1"}.}

\item{\code{port}}{Integer scalar. Server port. Default \code{7687L}.}

\item{\code{con}}{Socket connection object, or \code{NULL} when disconnected.}

\item{\code{auth_token}}{Character scalar or \code{NULL}. Optional
authentication token sent with every request.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-AstraeaClient-new}{\code{AstraeaClient$new()}}
\item \href{#method-AstraeaClient-connect}{\code{AstraeaClient$connect()}}
\item \href{#method-AstraeaClient-disconnect}{\code{AstraeaClient$disconnect()}}
\item \href{#method-AstraeaClient-is_connected}{\code{AstraeaClient$is_connected()}}
\item \href{#method-AstraeaClient-print}{\code{AstraeaClient$print()}}
\item \href{#method-AstraeaClient-ping}{\code{AstraeaClient$ping()}}
\item \href{#method-AstraeaClient-create_node}{\code{AstraeaClient$create_node()}}
\item \href{#method-AstraeaClient-get_node}{\code{AstraeaClient$get_node()}}
\item \href{#method-AstraeaClient-update_node}{\code{AstraeaClient$update_node()}}
\item \href{#method-AstraeaClient-delete_node}{\code{AstraeaClient$delete_node()}}
\item \href{#method-AstraeaClient-create_edge}{\code{AstraeaClient$create_edge()}}
\item \href{#method-AstraeaClient-get_edge}{\code{AstraeaClient$get_edge()}}
\item \href{#method-AstraeaClient-update_edge}{\code{AstraeaClient$update_edge()}}
\item \href{#method-AstraeaClient-delete_edge}{\code{AstraeaClient$delete_edge()}}
\item \href{#method-AstraeaClient-neighbors}{\code{AstraeaClient$neighbors()}}
\item \href{#method-AstraeaClient-bfs}{\code{AstraeaClient$bfs()}}
\item \href{#method-AstraeaClient-shortest_path}{\code{AstraeaClient$shortest_path()}}
\item \href{#method-AstraeaClient-neighbors_at}{\code{AstraeaClient$neighbors_at()}}
\item \href{#method-AstraeaClient-bfs_at}{\code{AstraeaClient$bfs_at()}}
\item \href{#method-AstraeaClient-shortest_path_at}{\code{AstraeaClient$shortest_path_at()}}
\item \href{#method-AstraeaClient-query}{\code{AstraeaClient$query()}}
\item \href{#method-AstraeaClient-vector_search}{\code{AstraeaClient$vector_search()}}
\item \href{#method-AstraeaClient-hybrid_search}{\code{AstraeaClient$hybrid_search()}}
\item \href{#method-AstraeaClient-semantic_neighbors}{\code{AstraeaClient$semantic_neighbors()}}
\item \href{#method-AstraeaClient-semantic_walk}{\code{AstraeaClient$semantic_walk()}}
\item \href{#method-AstraeaClient-extract_subgraph}{\code{AstraeaClient$extract_subgraph()}}
\item \href{#method-AstraeaClient-graph_rag}{\code{AstraeaClient$graph_rag()}}
\item \href{#method-AstraeaClient-anomaly_check}{\code{AstraeaClient$anomaly_check()}}
\item \href{#method-AstraeaClient-anomaly_stats}{\code{AstraeaClient$anomaly_stats()}}
\item \href{#method-AstraeaClient-anomaly_alerts}{\code{AstraeaClient$anomaly_alerts()}}
\item \href{#method-AstraeaClient-create_nodes}{\code{AstraeaClient$create_nodes()}}
\item \href{#method-AstraeaClient-create_edges}{\code{AstraeaClient$create_edges()}}
\item \href{#method-AstraeaClient-delete_nodes}{\code{AstraeaClient$delete_nodes()}}
\item \href{#method-AstraeaClient-delete_edges}{\code{AstraeaClient$delete_edges()}}
\item \href{#method-AstraeaClient-import_nodes_df}{\code{AstraeaClient$import_nodes_df()}}
\item \href{#method-AstraeaClient-import_edges_df}{\code{AstraeaClient$import_edges_df()}}
\item \href{#method-AstraeaClient-export_nodes_df}{\code{AstraeaClient$export_nodes_df()}}
\item \href{#method-AstraeaClient-export_bfs_df}{\code{AstraeaClient$export_bfs_df()}}
\item \href{#method-AstraeaClient-results_to_dataframe}{\code{AstraeaClient$results_to_dataframe()}}
\item \href{#method-AstraeaClient-nodes_to_dataframe}{\code{AstraeaClient$nodes_to_dataframe()}}
\item \href{#method-AstraeaClient-clone}{\code{AstraeaClient$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-new"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-new}{}}}
\subsection{Method \code{new()}}{
Create a new AstraeaDB client.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$new(host = "127.0.0.1", port = 7687L, auth_token = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{host}}{Character scalar. Server hostname.
Default \code{"127.0.0.1"}.}

\item{\code{port}}{Integer scalar. Server port. Default \code{7687L}.}

\item{\code{auth_token}}{Character scalar or \code{NULL}. Optional
authentication token.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \code{AstraeaClient} object (invisibly).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client <- AstraeaClient$new()
client <- AstraeaClient$new(host = "db.example.com", port = 7688L)
client <- AstraeaClient$new(auth_token = "my-secret-token")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-connect"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-connect}{}}}
\subsection{Method \code{connect()}}{
Open a TCP socket connection to the AstraeaDB server.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$connect()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The client object (invisibly), for method chaining.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client <- AstraeaClient$new()
client$connect()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-disconnect"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-disconnect}{}}}
\subsection{Method \code{disconnect()}}{
Close the TCP socket connection.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$disconnect()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The client object (invisibly).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client$disconnect()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-is_connected"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-is_connected}{}}}
\subsection{Method \code{is_connected()}}{
Check whether the client is currently connected.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$is_connected()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Logical scalar. \code{TRUE} if connected, \code{FALSE}
otherwise.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client$is_connected()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-print"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-print}{}}}
\subsection{Method \code{print()}}{
Print method showing connection status.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Ignored. Present for compatibility with the generic.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The client object (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-ping"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-ping}{}}}
\subsection{Method \code{ping()}}{
Health-check ping. Returns server information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$ping()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with server information (e.g., \code{version},
\code{pong}).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
info <- client$ping()
message(info$version)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-create_node"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-create_node}{}}}
\subsection{Method \code{create_node()}}{
Create a node.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$create_node(labels, properties, embedding = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{labels}}{Character vector of labels for the node.}

\item{\code{properties}}{Named list of node properties.}

\item{\code{embedding}}{Optional numeric vector. An embedding associated
with the node for vector search.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer scalar: the ID of the newly created node.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
nid <- client$create_node(
  labels = c("Person"),
  properties = list(name = "Alice", age = 30),
  embedding = c(0.1, 0.9, 0.3)
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-get_node"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-get_node}{}}}
\subsection{Method \code{get_node()}}{
Retrieve a node by its ID.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$get_node(node_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer scalar. The node ID to look up.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with \code{labels} (character vector) and
\code{properties} (named list).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
node <- client$get_node(1L)
node$labels
node$properties$name
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-update_node"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-update_node}{}}}
\subsection{Method \code{update_node()}}{
Update a node's properties using merge semantics. Existing
properties not present in the update are preserved.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$update_node(node_id, properties)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer scalar. The node ID to update.}

\item{\code{properties}}{Named list of properties to merge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data (invisibly).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client$update_node(1L, list(city = "San Francisco"))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-delete_node"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-delete_node}{}}}
\subsection{Method \code{delete_node()}}{
Delete a node and all edges connected to it.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$delete_node(node_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer scalar. The node ID to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data (invisibly).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client$delete_node(1L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-create_edge"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-create_edge}{}}}
\subsection{Method \code{create_edge()}}{
Create an edge between two nodes, with optional temporal validity.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$create_edge(
  source,
  target,
  edge_type,
  properties = list(),
  weight = 1,
  valid_from = NULL,
  valid_to = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{source}}{Integer scalar. Source node ID.}

\item{\code{target}}{Integer scalar. Target node ID.}

\item{\code{edge_type}}{Character scalar. The relationship type
(e.g., \code{"KNOWS"}).}

\item{\code{properties}}{Named list of edge properties.
Default \code{list()}.}

\item{\code{weight}}{Numeric scalar. Edge weight. Default \code{1.0}.}

\item{\code{valid_from}}{Numeric scalar or \code{NULL}. Start of temporal
validity window (milliseconds since epoch).}

\item{\code{valid_to}}{Numeric scalar or \code{NULL}. End of temporal
validity window (milliseconds since epoch).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer scalar: the ID of the newly created edge.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
eid <- client$create_edge(
  source    = 1L,
  target    = 2L,
  edge_type = "KNOWS",
  weight    = 0.9
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-get_edge"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-get_edge}{}}}
\subsection{Method \code{get_edge()}}{
Retrieve an edge by its ID.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$get_edge(edge_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_id}}{Integer scalar. The edge ID to look up.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with \code{source}, \code{target}, \code{edge_type},
\code{properties}, and optional temporal fields.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
edge <- client$get_edge(1L)
edge$edge_type
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-update_edge"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-update_edge}{}}}
\subsection{Method \code{update_edge()}}{
Update an edge's properties using merge semantics.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$update_edge(edge_id, properties)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_id}}{Integer scalar. The edge ID to update.}

\item{\code{properties}}{Named list of properties to merge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data (invisibly).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client$update_edge(1L, list(strength = "strong"))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-delete_edge"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-delete_edge}{}}}
\subsection{Method \code{delete_edge()}}{
Delete an edge.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$delete_edge(edge_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_id}}{Integer scalar. The edge ID to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The server response data (invisibly).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
client$delete_edge(1L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-neighbors"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-neighbors}{}}}
\subsection{Method \code{neighbors()}}{
Get neighbors of a node, optionally filtered by direction and edge
type.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$neighbors(node_id, direction = "outgoing", edge_type = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer scalar. The node whose neighbors to retrieve.}

\item{\code{direction}}{Character scalar. One of \code{"outgoing"},
\code{"incoming"}, or \code{"both"}. Default \code{"outgoing"}.}

\item{\code{edge_type}}{Character scalar or \code{NULL}. If non-\code{NULL},
only return neighbors connected by this edge type.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of neighbor entries. Each entry is a list with at
least \code{node_id} and \code{edge_id}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
nbrs <- client$neighbors(1L, direction = "outgoing")
nbrs_knows <- client$neighbors(1L, edge_type = "KNOWS")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-bfs"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-bfs}{}}}
\subsection{Method \code{bfs()}}{
Breadth-first search starting from a node.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$bfs(start, max_depth = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer scalar. The starting node ID.}

\item{\code{max_depth}}{Integer scalar. Maximum traversal depth.
Default \code{3L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of entries, each a list with \code{node_id} (integer)
and \code{depth} (integer).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
bfs_result <- client$bfs(1L, max_depth = 2L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-shortest_path"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-shortest_path}{}}}
\subsection{Method \code{shortest_path()}}{
Find the shortest path between two nodes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$shortest_path(from_node, to_node, weighted = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_node}}{Integer scalar. Source node ID.}

\item{\code{to_node}}{Integer scalar. Target node ID.}

\item{\code{weighted}}{Logical scalar. If \code{TRUE}, use edge weights
(Dijkstra). If \code{FALSE}, use hop count. Default \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with \code{path} (integer vector of node IDs),
\code{length} (hop count), and optionally \code{cost} (total weight
when \code{weighted = TRUE}).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
sp <- client$shortest_path(1L, 5L, weighted = TRUE)
sp$path
sp$cost
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-neighbors_at"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-neighbors_at}{}}}
\subsection{Method \code{neighbors_at()}}{
Get neighbors of a node at a specific point in time. Only edges
whose temporal validity window includes \code{timestamp} are
traversed.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$neighbors_at(
  node_id,
  direction = "outgoing",
  timestamp,
  edge_type = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer scalar. The node whose neighbors to retrieve.}

\item{\code{direction}}{Character scalar. One of \code{"outgoing"},
\code{"incoming"}, or \code{"both"}. Default \code{"outgoing"}.}

\item{\code{timestamp}}{Numeric scalar. Point in time as milliseconds since
the Unix epoch.}

\item{\code{edge_type}}{Character scalar or \code{NULL}. Optional edge type
filter.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of neighbor entries valid at the given timestamp.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# Neighbors as of January 1 2023 (ms since epoch)
nbrs <- client$neighbors_at(1L, "outgoing", 1672531200000)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-bfs_at"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-bfs_at}{}}}
\subsection{Method \code{bfs_at()}}{
Breadth-first search at a specific point in time.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$bfs_at(start, max_depth = 3L, timestamp)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer scalar. The starting node ID.}

\item{\code{max_depth}}{Integer scalar. Maximum traversal depth.
Default \code{3L}.}

\item{\code{timestamp}}{Numeric scalar. Point in time (ms since epoch).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of entries with \code{node_id} and \code{depth}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
result <- client$bfs_at(1L, max_depth = 2L, timestamp = 1672531200000)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-shortest_path_at"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-shortest_path_at}{}}}
\subsection{Method \code{shortest_path_at()}}{
Find the shortest path at a specific point in time.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$shortest_path_at(from_node, to_node, timestamp, weighted = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_node}}{Integer scalar. Source node ID.}

\item{\code{to_node}}{Integer scalar. Target node ID.}

\item{\code{timestamp}}{Numeric scalar. Point in time (ms since epoch).}

\item{\code{weighted}}{Logical scalar. Use edge weights? Default
\code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with \code{path}, \code{length}, and optionally
\code{cost}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
sp <- client$shortest_path_at(1L, 5L, timestamp = 1672531200000)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-query"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-query}{}}}
\subsection{Method \code{query()}}{
Execute a GQL (Graph Query Language) query string.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$query(gql)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gql}}{Character scalar. The GQL query to execute.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The query result data as returned by the server.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
result <- client$query("MATCH (p:Person) RETURN p.name, p.city")
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-vector_search"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-vector_search}{}}}
\subsection{Method \code{vector_search()}}{
Perform k-nearest neighbor vector similarity search.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$vector_search(query_vector, k = 10L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query_vector}}{Numeric vector. The query embedding.}

\item{\code{k}}{Integer scalar. Number of nearest neighbors to return.
Default \code{10L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of result entries, each containing at least
\code{node_id} and \code{similarity}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
results <- client$vector_search(c(0.9, 0.1, 0.3), k = 5L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-hybrid_search"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-hybrid_search}{}}}
\subsection{Method \code{hybrid_search()}}{
Combined graph proximity and vector similarity search.

The \code{alpha} parameter controls the blend between graph
proximity and vector similarity. \code{alpha = 0.0} uses pure
graph distance; \code{alpha = 1.0} uses pure vector similarity.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$hybrid_search(
  anchor,
  query_vector,
  max_hops = 3L,
  k = 10L,
  alpha = 0.5
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{anchor}}{Integer scalar. Anchor node ID for graph proximity.}

\item{\code{query_vector}}{Numeric vector. Query embedding.}

\item{\code{max_hops}}{Integer scalar. Maximum graph hops from anchor.
Default \code{3L}.}

\item{\code{k}}{Integer scalar. Number of results. Default \code{10L}.}

\item{\code{alpha}}{Numeric scalar in \code{[0, 1]}. Blend factor.
Default \code{0.5}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of result entries with \code{node_id} and combined
scores.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
results <- client$hybrid_search(
  anchor = 1L,
  query_vector = c(0.9, 0.1, 0.3),
  k = 5L,
  alpha = 0.7
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-semantic_neighbors"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-semantic_neighbors}{}}}
\subsection{Method \code{semantic_neighbors()}}{
Get neighbors ranked by semantic similarity to a concept vector.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$semantic_neighbors(
  node_id,
  concept,
  direction = "outgoing",
  k = 10L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_id}}{Integer scalar. The node whose neighbors to rank.}

\item{\code{concept}}{Numeric vector. The concept embedding to rank
against.}

\item{\code{direction}}{Character scalar. One of \code{"outgoing"},
\code{"incoming"}, or \code{"both"}. Default \code{"outgoing"}.}

\item{\code{k}}{Integer scalar. Maximum number of ranked neighbors.
Default \code{10L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of neighbor entries with \code{node_id} and
\code{similarity} scores.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
nbrs <- client$semantic_neighbors(1L, c(0.0, 0.0, 1.0), k = 5L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-semantic_walk"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-semantic_walk}{}}}
\subsection{Method \code{semantic_walk()}}{
Greedy walk following edges whose targets are most similar to a
concept vector.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$semantic_walk(start, concept, max_hops = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer scalar. Starting node ID.}

\item{\code{concept}}{Numeric vector. Concept embedding guiding the walk.}

\item{\code{max_hops}}{Integer scalar. Maximum walk length.
Default \code{3L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list representing the walk path.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
path <- client$semantic_walk(1L, c(0.1, 0.8, 0.5), max_hops = 4L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-extract_subgraph"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-extract_subgraph}{}}}
\subsection{Method \code{extract_subgraph()}}{
Extract a subgraph centered on a node and linearize it to text.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$extract_subgraph(
  center,
  hops = 2L,
  max_nodes = 50L,
  format = "structured"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{center}}{Integer scalar. Center node ID.}

\item{\code{hops}}{Integer scalar. Radius in hops. Default \code{2L}.}

\item{\code{max_nodes}}{Integer scalar. Maximum number of nodes to include.
Default \code{50L}.}

\item{\code{format}}{Character scalar. Output format: one of
\code{"structured"}, \code{"prose"}, \code{"triples"}, or
\code{"json"}. Default \code{"structured"}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with extracted subgraph data including \code{text},
\code{node_count}, and \code{edge_count}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
sg <- client$extract_subgraph(1L, hops = 2L, max_nodes = 20L)
sg$text
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-graph_rag"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-graph_rag}{}}}
\subsection{Method \code{graph_rag()}}{
Execute a full GraphRAG pipeline: extract a subgraph and send it to
a language model.

Provide either \code{anchor} (a node ID to center the subgraph on)
or \code{question_embedding} (a vector to locate the closest node
via vector search), or both.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$graph_rag(
  question,
  anchor = NULL,
  question_embedding = NULL,
  hops = 2L,
  max_nodes = 50L,
  format = "structured"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{question}}{Character scalar. The natural-language question.}

\item{\code{anchor}}{Integer scalar or \code{NULL}. Anchor node ID.}

\item{\code{question_embedding}}{Numeric vector or \code{NULL}. Embedding
of the question for vector-based anchor selection.}

\item{\code{hops}}{Integer scalar. Subgraph radius. Default \code{2L}.}

\item{\code{max_nodes}}{Integer scalar. Maximum subgraph nodes.
Default \code{50L}.}

\item{\code{format}}{Character scalar. Linearization format.
Default \code{"structured"}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the RAG result, typically including an
\code{answer} field.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
answer <- client$graph_rag(
  question = "What does Alice work on?",
  anchor = 1L
)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-anomaly_check"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-anomaly_check}{}}}
\subsection{Method \code{anomaly_check()}}{
Check the anomaly status of a node or edge.

Uses AstraeaDB's "deja vu" anomaly detection algorithm to assess
whether an entity's recent behavior is anomalous.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$anomaly_check(entity_id, is_node = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{entity_id}}{Integer scalar. The node or edge ID to check.}

\item{\code{is_node}}{Logical scalar. If \code{TRUE} (default), check a
node; if \code{FALSE}, check an edge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with anomaly score information, or a message
indicating no data is available yet.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
result <- client$anomaly_check(1L)
result <- client$anomaly_check(5L, is_node = FALSE)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-anomaly_stats"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-anomaly_stats}{}}}
\subsection{Method \code{anomaly_stats()}}{
Get detailed anomaly statistics for a node or edge.

Returns more detailed information than \code{anomaly_check()},
including historical anomaly scores and thresholds.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$anomaly_stats(entity_id, is_node = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{entity_id}}{Integer scalar. The node or edge ID.}

\item{\code{is_node}}{Logical scalar. If \code{TRUE} (default), query a
node; if \code{FALSE}, query an edge.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with detailed anomaly statistics.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
stats <- client$anomaly_stats(1L)
stats <- client$anomaly_stats(5L, is_node = FALSE)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-anomaly_alerts"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-anomaly_alerts}{}}}
\subsection{Method \code{anomaly_alerts()}}{
Get all active anomaly alerts.

Returns a list of currently active anomaly alerts detected by the
server's "deja vu" algorithm.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$anomaly_alerts()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of alert entries. Each entry describes an anomalous
entity and its anomaly score.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
alerts <- client$anomaly_alerts()
for (a in alerts) {
  cat(sprintf("Entity \%d: score \%.2f\n", a$id, a$score))
}
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-create_nodes"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-create_nodes}{}}}
\subsection{Method \code{create_nodes()}}{
Create multiple nodes in a single batch.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$create_nodes(nodes_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nodes_list}}{A list of node specifications. Each element must
be a list with \code{labels} (character vector) and
\code{properties} (named list). An optional \code{embedding}
(numeric vector) may be included.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created node IDs, in the same order as
the input.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
ids <- client$create_nodes(list(
  list(labels = "Person", properties = list(name = "Alice")),
  list(labels = "Person", properties = list(name = "Bob"))
))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-create_edges"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-create_edges}{}}}
\subsection{Method \code{create_edges()}}{
Create multiple edges in a single batch.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$create_edges(edges_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edges_list}}{A list of edge specifications. Each element must
be a list with \code{source}, \code{target}, and \code{edge_type}.
Optional fields: \code{properties}, \code{weight},
\code{valid_from}, \code{valid_to}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created edge IDs, in the same order as
the input.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
eids <- client$create_edges(list(
  list(source = 1L, target = 2L, edge_type = "KNOWS"),
  list(source = 2L, target = 3L, edge_type = "FOLLOWS", weight = 0.5)
))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-delete_nodes"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-delete_nodes}{}}}
\subsection{Method \code{delete_nodes()}}{
Delete multiple nodes. Errors for individual nodes are silently
skipped.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$delete_nodes(node_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_ids}}{Integer vector of node IDs to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer scalar: the count of successfully deleted nodes.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
deleted <- client$delete_nodes(c(1L, 2L, 3L))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-delete_edges"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-delete_edges}{}}}
\subsection{Method \code{delete_edges()}}{
Delete multiple edges. Errors for individual edges are silently
skipped.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$delete_edges(edge_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{edge_ids}}{Integer vector of edge IDs to delete.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Integer scalar: the count of successfully deleted edges.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
deleted <- client$delete_edges(c(1L, 2L))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-import_nodes_df"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-import_nodes_df}{}}}
\subsection{Method \code{import_nodes_df()}}{
Import nodes from a \code{data.frame}.

Each row becomes a node. One column supplies the label(s), and the
remaining columns (excluding any embedding columns) become node
properties.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$import_nodes_df(
  df,
  label_col = "label",
  id_col = NULL,
  embedding_cols = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{A \code{data.frame} with one row per node.}

\item{\code{label_col}}{Character scalar. Name of the column containing
node labels. Default \code{"label"}.}

\item{\code{id_col}}{Character scalar or \code{NULL}. If non-\code{NULL},
this column is stored in the node properties as an external
identifier.}

\item{\code{embedding_cols}}{Character vector or \code{NULL}. Column names
whose values form the embedding vector.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created node IDs.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- data.frame(
  label = c("Person", "Person"),
  name  = c("Alice", "Bob"),
  age   = c(30, 25),
  stringsAsFactors = FALSE
)
ids <- client$import_nodes_df(df)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-import_edges_df"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-import_edges_df}{}}}
\subsection{Method \code{import_edges_df()}}{
Import edges from a \code{data.frame}.

Each row becomes an edge. Columns supply the source/target node IDs,
edge type, and optionally weight and temporal bounds. Remaining
columns become edge properties.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$import_edges_df(
  df,
  source_col = "source",
  target_col = "target",
  type_col = "type",
  weight_col = NULL,
  valid_from_col = NULL,
  valid_to_col = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{A \code{data.frame} with one row per edge.}

\item{\code{source_col}}{Character scalar. Column with source node IDs.
Default \code{"source"}.}

\item{\code{target_col}}{Character scalar. Column with target node IDs.
Default \code{"target"}.}

\item{\code{type_col}}{Character scalar. Column with edge type strings.
Default \code{"type"}.}

\item{\code{weight_col}}{Character scalar or \code{NULL}. Column with edge
weights.}

\item{\code{valid_from_col}}{Character scalar or \code{NULL}. Column with
temporal start (ms since epoch).}

\item{\code{valid_to_col}}{Character scalar or \code{NULL}. Column with
temporal end (ms since epoch).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An integer vector of created edge IDs.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
edf <- data.frame(
  source = c(1L, 2L),
  target = c(2L, 3L),
  type   = c("KNOWS", "FOLLOWS"),
  stringsAsFactors = FALSE
)
eids <- client$import_edges_df(edf)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-export_nodes_df"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-export_nodes_df}{}}}
\subsection{Method \code{export_nodes_df()}}{
Export nodes to a \code{data.frame} with \code{node_id}, a
comma-separated \code{labels} column, and flattened property
columns.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$export_nodes_df(node_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_ids}}{Integer vector of node IDs to export.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame} with one row per node.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- client$export_nodes_df(c(1L, 2L, 3L))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-export_bfs_df"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-export_bfs_df}{}}}
\subsection{Method \code{export_bfs_df()}}{
Run BFS from a starting node and return the results as a
\code{data.frame} that includes node details.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$export_bfs_df(start, max_depth = 3L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{start}}{Integer scalar. Starting node ID.}

\item{\code{max_depth}}{Integer scalar. Maximum BFS depth.
Default \code{3L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame} with \code{node_id}, \code{depth},
\code{labels}, and flattened property columns.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
bfs_df <- client$export_bfs_df(1L, max_depth = 2L)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-results_to_dataframe"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-results_to_dataframe}{}}}
\subsection{Method \code{results_to_dataframe()}}{
Convert a list of search results to a \code{data.frame}.

This is a convenience method for converting results from
\code{vector_search()}, \code{hybrid_search()}, or similar methods
into a tabular format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$results_to_dataframe(results)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{results}}{A list of result entries (e.g., from
\code{vector_search()}). Each entry should be a list with named
elements.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame} with one row per result entry. Returns
an empty \code{data.frame} if \code{results} is empty.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
results <- client$vector_search(c(0.9, 0.1, 0.3), k = 5L)
df <- client$results_to_dataframe(results)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-nodes_to_dataframe"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-nodes_to_dataframe}{}}}
\subsection{Method \code{nodes_to_dataframe()}}{
Fetch multiple nodes by ID and return as a \code{data.frame}.

Similar to \code{export_nodes_df()} but preserves the \code{labels}
column as a list column (using \code{\link[base]{I}}) rather than
collapsing to a comma-separated string.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$nodes_to_dataframe(node_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{node_ids}}{Integer vector of node IDs to fetch.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A \code{data.frame} with columns \code{id}, \code{labels}
(list column), and flattened property columns.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
df <- client$nodes_to_dataframe(c(1L, 2L, 3L))
df$labels[[1]]
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-AstraeaClient-clone"></a>}}
\if{latex}{\out{\hypertarget{method-AstraeaClient-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{AstraeaClient$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
